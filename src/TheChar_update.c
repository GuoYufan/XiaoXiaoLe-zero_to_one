#include <stdio.h>
#include <stdlib.h>
#include "../include/XiaoXiaoLe.h"
#include "../include/哈希表.h"
#include "../include/GYF.h"

// 记录该字符串中每个字符情况（相对于对手）
// 感觉要不要——或者说有什么办法可以跳过不可消除的（从未出现的、或消除过几次后再也不能出现的）字符而不记录它们呢？
// 现在的情况下，如果用哈希表查找到，得知其不再出现，于是我不记录，而直接continue掉了。
// 那么，*p_每个字符情况，每次循环还是在malloc分配新内存空间返回一个地址值。
// 那么，而循环次数就是有多少个字符就是循环多少次。
// 那么，造成*p_每个字符情况会malloc出大量我没使用的空间，这些空间全部被初始化为“空”“0”。
// 我躲掉那些再也不可消除的字符，以为节省了；事实上还是存在浪费没完全避开。
bool TheChar_update_按顺序映射关系(TheWord* 我方, char* 对方内容, HashTable* ht)
{
	if (*(我方->内容) =='\0'|| *对方内容=='\0')
	{
		printf("❗️双方有其中一方无任何内容，不需要消除\n");
		return false;
	}
	char* pos_address = NULL;
	char 占位符集[2] = {'-','_'};
	char 占位符序号 = 0;
	
	char* p_我方内容 = 我方->内容;
	TheChar** p_每个字符情况 = 我方->每个字符情况;
	我方->记录了几个字符情况 = 0;
	TheChar* self = NULL;
	
	// 考虑在更靠后的位置出现已消除过的内容，从而“首次出现在对方哪个位置”失效的情况
	char* 最近相同内容消除到哪里 = 对方内容;
	if (gyf_debug_mode->DoesMsgPrint) {
		printf("最近相同内容消除到哪里：%s\n",最近相同内容消除到哪里);
		getchar();
	}
	short* 哈希表查找结果=NULL;

	// 遍历我方字符串
	for (short pos_index=0; *p_我方内容 != '\0'; pos_index++, p_我方内容++)
	{		
		// 对遍历到的当前字符检查哈希表记录
		哈希表查找结果 = HashTable_search(ht, *p_我方内容);
		
		// 如果该字符已经被检查过至少一次，且该字符的下次消除检查起始点是无效的：如从结尾之后开始检查。
		// 不需要继续记录该字符情况
		if (哈希表查找结果 != NULL && *哈希表查找结果 <0 ){
			continue;
		}
		
		self = *p_每个字符情况 = (TheChar*) malloc(sizeof (TheChar) );
		p_每个字符情况++;
		我方->记录了几个字符情况++;
		printf("需要记录情况的第%d个字符\n", 我方->记录了几个字符情况);
		
		// 遍历到的当前pos_index就是当前字符情况的在自身哪个位置
		self->在自身哪个位置 = pos_index;
		
		// 如果该字符已经被检查过至少一次，且该字符的下次消除检查起始点是有效的。
		// 在哈希表里已创建对象（分配空间储存信息）而有所记录。
		if (哈希表查找结果 != NULL) {
			最近相同内容消除到哪里 = 对方内容 + *哈希表查找结果 + 1;
		} else
			// 如果该字符从未被检查，且该字符的下次消除检查起始点是有效的。
			// 在哈希表里未有记录。
			最近相同内容消除到哪里 = 对方内容;
		
		if (gyf_debug_mode->DoesMsgPrint) {
			printf("当前字符:%c\n最近相同内容消除到哪里：%s",
			*p_我方内容, 最近相同内容消除到哪里);
			getchar();
		}
			
		// 我方字符串的当前检查到的字符是否出现在对方以及获取首次出现的位置。
		// 获取到的位置是指针表示的。用指针相减得到索引表示的位置。
		// 下次消除检查起始点必须是上次消除点的下一位。
		pos_address = strchr( 最近相同内容消除到哪里, *p_我方内容);
		
		// 《在上次相同内容被消除之后首次出现在哪里》
		// 如果出现在对方，则记录该内容出现在对方哪个位置。
		// 以及将该内容在这份存档中正常显示。
		if (pos_address != NULL)
		{
			self->首次出现在对方哪个位置 = pos_address - 对方内容;
			self->内容 = *p_我方内容;			
		}
		// 如果未出现在对方，将索引号记为-2。（因为如果-1再+1不是后移，而是回到开头，又能搜索了。）
		// 将该内容以占位符显示。
		else
		{
			self->首次出现在对方哪个位置 = -1;
			//占位符序号 = 1 - 占位符序号;
			//self->内容 = 占位符集[占位符序号];
			self->内容 = *p_我方内容;
		}

		// 将该内容最近一次消除位置记录在哈希表中
		// 该值在使用时加1用以表示下次消除检查起始点
		// 不使用时保持为上次消除点位置，不需要加1，不需要到下一位
		// 因为这样这个数字与需要求解的数字是相同的。
		HashTable_create(ht, self->内容, self->首次出现在对方哪个位置);
		if (gyf_debug_mode->DoesMsgPrint){
			printf("消除的或不消除的记录于哈希表：(%c,%d)\n",
				ht->table[hash(self->内容)]->key,
				ht->table[hash(self->内容)]->value);
			getchar();
		}
	}
	
	return true;
}